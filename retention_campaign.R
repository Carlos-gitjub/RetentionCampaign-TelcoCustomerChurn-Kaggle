library(knitr)
library(dplyr)
library(ggplot2)
library(GGally)
library(reshape2)
library(tidyr)

# Loading the data. NOTE: text is set as factor data type
churn_data<- read.csv("WA_Fn-UseC_-Telco-Customer-Churn.csv", sep = ",", stringsAsFactors = TRUE)
# SeniorCitizen variable is converted from numeric to factor so it can be interpreted as a categorical.
churn_data$SeniorCitizen<-factor(churn_data$SeniorCitizen)

# data types, column summaries, etc
str(churn_data)
summary(churn_data)

# frequency diagrams of Churn and categorical variables.
variables_cualitativas<- c("gender", "SeniorCitizen", "Partner", "Dependents",
                           "PhoneService", "MultipleLines", "InternetService",
                           "OnlineSecurity", "OnlineBackup", "DeviceProtection",
                           "TechSupport", "StreamingTV", "StreamingMovies", 
                           "Contract", "PaperlessBilling", "PaymentMethod",
                           "Churn")
tmp.cuant.churn<- melt(churn_data, id="Churn", measure=variables_cualitativas)
ggplot(tmp.cuant.churn) + geom_bar(aes(value, fill=Churn)) + facet_wrap(~variable, scales = "free_x") +
  theme( axis.text.x = element_text(angle = 15))

# histograms of Churn and categorical variable
variables_cuantitativas<- c("tenure","MonthlyCharges", "TotalCharges")
tmp.cual.churn<- melt(churn_data, id="Churn", measure=variables_cuantitativas)
ggplot(tmp.cual.churn) + geom_histogram(aes(value, fill=Churn)) +
  facet_wrap(~variable, scales = "free_x")

# boxplot of the MonthlyCharges distribution for each value of the categorical variables.
tmp.cual.monthly<- melt(churn_data[c(variables_cualitativas,"MonthlyCharges")], 
                        id="MonthlyCharges", measure=variables_cualitativas)

ggplot(tmp.cual.monthly) + geom_boxplot(aes(value, MonthlyCharges)) +
  facet_wrap(~variable, scales = "free_x") +
  theme(axis.text.x = element_text(angle=15))

# Scatterplot matrix to visualize the correlation between variables.
tmp.cuant.monthly<- churn_data[variables_cuantitativas]
ggpairs(tmp.cuant.monthly)

# checking for missing data in the dataset
colSums(is.na(churn_data))

# creation of training and test sets  
churn_train<-churn_data[1:5000,]
churn_test<-churn_data[5001:nrow(churn_data),]

# Model for predicting customer churn. Logistic Regression (all variables are used)
mod.rlogit=glm(Churn ~ ., data = churn_train[, !names(churn_train) %in% "customerID"], family=binomial)

probs<-predict(mod.rlogit, newdata = churn_test, type = "response")
churn_pred<-factor(ifelse(probs>0.5, "Yes", "No"))

# Confusion matrix of the model prediction.
(t=table(churn_test$Churn, churn_pred))

# Overall model accuracy
( precision_global<-(t[1,1] + t[2,2])/nrow(churn_test) )
# False positive rate
( ratio_falsos_positivos<-t[1,2]/(t[1,2]+t[1,1]) )
# False negative rate
( ratio_falsos_negativos<-t[1,1]/(t[1,1]+t[2,2]) )
# True positive rate
( ratio_verdaderos_positivos <-t[2,2]/(t[2,2]+t[2,1]) )


# Similar model for predicting customer churn using Logistic Regression. This time, the variables used are: Contract, Tenure and InternetService.
mod.rlogit2<-glm(Churn ~ ., data = churn_train[,c("Churn", "Contract", "tenure", "InternetService")], family = binomial)

probs<-predict(mod.rlogit2, newdata=churn_test, type="response")
churn_pred2=factor(ifelse(probs>0.5, "Yes", "No"))
# Confusion matrix
( t<-table(churn_test$Churn, churn_pred2) )

# Overall model accuracy
( precision_global<-(t[1,1] + t[2,2])/nrow(churn_test) )
# False positive rate
( ratio_falsos_positivos<-t[1,2]/(t[1,2]+t[1,1]) )
# False negative rate
( ratio_falsos_negativos<-t[1,1]/(t[1,1]+t[2,2]) )
# True positive rate
( ratio_verdaderos_positivos <-t[2,2]/(t[2,2]+t[2,1]) )


# Retention campaign simulation
probs<-predict(mod.rlogit, newdata=churn_test, type = "response")
up<-seq(0, 1, by=0.1)
preds.umbrales<-data.frame(probs=probs, Churn=churn_test$Churn)

# predictions for different probability thresholds 
for(u in up){
  x<-factor(ifelse(probs>u, "Yes", "No"), levels = c("No", "Yes"))
  preds.umbrales<-cbind(preds.umbrales, as.data.frame(x))
}
colnames(preds.umbrales)<-c("probs","Churn", paste0("churn_pred_", up))

# Confusion matrix
t.list<-list()
for (i in 3:ncol(preds.umbrales)) {
  t<- table(churn_test$Churn, preds.umbrales[,i])
  t.list<-append(t.list, list(t))
}
print(t.list)

# Scenario 1
I=200
AR=0.4
R=500
vector_Beneficios<-c()
for (i in 1:length(t.list)) {
  TN=t.list[[i]][1,1]
  FP=t.list[[i]][1,2]
  FN=t.list[[i]][2,1]
  TP=t.list[[i]][2,2]
  
  ResultadoConCampania= - FP*AR*I - TP*AR*I - TP*(1-AR)*R - FN*R
  ResultadoSinCampania= - (FN + TP)*R
  Beneficio= ResultadoConCampania - ResultadoSinCampania
  
  cat(colnames(preds.umbrales)[i+2],": ", Beneficio,"\n", sep = "")
  vector_Beneficios<-c(vector_Beneficios, Beneficio)
}

# Benefits generated by the best threshold
( max_bens1<-max(vector_Beneficios) )

# Scenario 2
I=400
AR=0.8
R=500
vector_Beneficios<-c()
for (i in 1:length(t.list)) {
  TN=t.list[[i]][1,1]
  FP=t.list[[i]][1,2]
  FN=t.list[[i]][2,1]
  TP=t.list[[i]][2,2]
  
  ResultadoConCampania= - FP*AR*I - TP*AR*I - TP*(1-AR)*R - FN*R
  ResultadoSinCampania= - (FN + TP)*R
  Beneficio= ResultadoConCampania - ResultadoSinCampania
  
  cat(colnames(preds.umbrales)[i+2],": ", Beneficio,"\n", sep = "")
  vector_Beneficios<-c(vector_Beneficios, Beneficio)
}

max(vector_Beneficios)

# The best results are obtained with the campaign that uses less incentive.
